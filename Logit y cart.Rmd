---
title: "Logit y Cart: Stacking para Predicción de Precio Alto/Bajo"
author: "Lina Alvarez Ardila - Sara Rocio Rojas"
date: "`r Sys.Date()`"
output: pdf_document
---

## Introducción

En este documento implementamos un modelo de stacking que combina una regresión logística (*Logit*) y un árbol de decisión (*CART*) para predecir si el precio de una vivienda es alto o bajo (según la mediana de precios observada).  
Utilizamos validación cruzada normal para evaluar el desempeño y generamos un archivo de predicción para el set de test.

---

## Preparación

```{r libraries, message=FALSE, warning=FALSE}
library(tidyverse)
library(caret)
library(rpart)
library(pROC)

# Carga de datos
test <- read_csv("https://www.dropbox.com/scl/fi/seif0x3qoy95gh0s2nw0u/test.csv?rlkey=lqzviqjqxwatlt708bzoezsnc&st=csqy50ti&dl=1")
train <- read_csv("https://www.dropbox.com/scl/fi/pnw43edk4uewsd13g1oxj/train.csv?rlkey=vxuc9vej4ruom9dg0y5b2zh0c&st=1zp7ez1e&dl=1")

# Definición variable objetivo binaria
med_price <- median(train$price, na.rm=TRUE)
train$y <- as.integer(train$price >= med_price)

# Variables predictoras seleccionadas (estructurales + dummies principales)
vars_usar <- c(
  "surface_total", "surface_covered", "rooms", "bedrooms", "bathrooms",
  "property_type", "surface_total_imputed", "surface_covered_imputed",
  "rooms_imputed", "bathrooms_imputed", "dist_colegio", "dist_parque",
  "estrato_manzana", "num_gastrobares_500m", "dummy_remodelado", "dummy_lujoso",
  "dummy_vista", "dummy_amoblado", "num_airbnb_1500m"
)
X_train <- train %>% select(all_of(vars_usar))
X_test  <- test %>% select(all_of(vars_usar))
y <- train$y

# Conversión a factor donde corresponda
X_train <- X_train %>% mutate(across(where(is.character), as.factor))
X_test  <- X_test %>% mutate(across(where(is.character), as.factor))

# Imputación simple de NAs (mediana para numéricas, moda para factores)
for (col in names(X_train)) {
  if (is.numeric(X_train[[col]])) {
    med <- median(X_train[[col]], na.rm=TRUE)
    X_train[[col]][is.na(X_train[[col]])] <- med
    X_test[[col]][is.na(X_test[[col]])] <- med
  } else {
    mode_val <- names(sort(table(X_train[[col]]), decreasing=TRUE))[1]
    X_train[[col]][is.na(X_train[[col]])] <- mode_val
    X_test[[col]][is.na(X_test[[col]])] <- mode_val
  }
}
set.seed(42)
folds_normal <- createFolds(y, k = 5, list = TRUE, returnTrain = FALSE)

```

## Stacking Logit y CART con Validación Cruzada

```{r}
# Función para obtener predicciones out-of-fold para stacking
get_oof_preds <- function(X, y, folds) {
  n <- nrow(X)
  preds_logit <- rep(NA, n)
  preds_cart <- rep(NA, n)
  for (i in seq_along(folds)) {
    idx_valid <- folds[[i]]
    idx_train <- setdiff(seq_len(n), idx_valid)
    modelo_logit <- glm(y[idx_train] ~ ., data = X[idx_train,], family = binomial)
    preds_logit[idx_valid] <- predict(modelo_logit, newdata = X[idx_valid,], type = "response")
    modelo_cart <- rpart(y[idx_train] ~ ., data = X[idx_train,], method = "class", control = rpart.control(cp = 0.01))
    preds_cart[idx_valid] <- predict(modelo_cart, newdata = X[idx_valid,], type = "prob")[,2]
  }
  data.frame(pred_logit = preds_logit, pred_cart = preds_cart)
}

# Out-of-fold predictions para stacking
oof_preds_normal <- get_oof_preds(X_train, y, folds_normal)
meta_normal <- glm(y ~ pred_logit + pred_cart, data = as.data.frame(cbind(y = y, oof_preds_normal)), family = binomial)
auc_normal <- pROC::auc(y, predict(meta_normal, type = "response"))

# Modelos completos y predicción en test
modelo_logit_full <- glm(y ~ ., data = X_train, family = binomial)
modelo_cart_full  <- rpart(y ~ ., data = X_train, method = "class", control = rpart.control(cp = 0.01))
pred_test_logit <- predict(modelo_logit_full, newdata = X_test, type = "response")
pred_test_cart  <- predict(modelo_cart_full, newdata = X_test, type = "prob")[,2]
pred_test_stack <- predict(meta_normal, newdata = data.frame(pred_logit = pred_test_logit, pred_cart = pred_test_cart), type = "response")

# Exporta submission listo para Kaggle
submission <- data.frame(property_id = test$property_id, price = pred_test_stack)
write_csv(submission, "stacking_logit_cart_submission.csv")
```
## Resultados del modelo

```{r}
# AUC y Accuracy
cat("AUC stacking (VC normal):", auc_normal, "\n")
train_preds_prob <- predict(meta_normal, type = "response")
train_preds_class <- ifelse(train_preds_prob >= 0.5, 1, 0)
acc <- mean(train_preds_class == y)
cat("Accuracy stacking (VC normal):", acc, "\n")

# Matriz de confusión
cm <- confusionMatrix(as.factor(train_preds_class), as.factor(y), positive = "1")
print(cm)
```